#!/usr/bin/env python
# arima_mapping 0.0.1
# Generated by dx-app-wizard.
#
# Basic execution pattern: Your app will run on a single machine from
# beginning to end.
#
# See https://wiki.dnanexus.com/Developer-Portal for documentation and
# tutorials on how to modify this file.
#
# DNAnexus Python Bindings (dxpy) documentation:
#   http://autodoc.dnanexus.com/bindings/python/current/

import os
import dx_utils
import re
import multiprocessing

import dxpy

@dxpy.entry_point('run_bwa')
def run_bwa(reads, ref_genome):
    dx_utils.download_and_gunzip_file(ref_genome)
    bwt_filename = dx_utils.run_cmd('ls *.bwt', returnOutput=True).strip()
    genome_prefix = os.path.splitext(bwt_filename)[0]

    # download reads
    reads = dx_utils.download_and_gunzip_file(reads, skip_decompress=True, create_named_pipe=True)
    ofn = re.sub('.f(ast)?q[.gz]*$', '.bam', reads)

    cmd = 'bwa mem -t {0} -B 8 {1} {2} '.format(multiprocessing.cpu_count(), genome_prefix, reads)
    cmd += '| perl ./filter_five_end.pl | samtools view -@{0} -Sb - > {1} '.format(multiprocessing.cpu_count(), ofn)
    dx_utils.run_cmd(cmd)

    return {'output_bam': dxpy.dxlink(dxpy.upload_local_file(ofn))}

@dxpy.entry_point('combine_bams')
def combine_bams(fwd_bam, rev_bam):
    fwd_bam = [dx_utils.download_and_gunzip_file(fwd, create_named_pipe=True) for fwd in fwd_bam]
    rev_bam = [dx_utils.download_and_gunzip_file(rev, create_named_pipe=True) for rev in rev_bam]

    cmd_fwd = ["bamtools", "merge"]
    cmd_rev = cmd_fwd.copy()
    for fwd, rev in zip(fwd_bam, rev_bam):
        cmd_fwd.extend(["-in", fwd])
        cmd_rev.extend(["-in", rev])

    fwd_ofn = re.sub("(_1)?(_R1)?.bam$", "_R1.bam", os.path.commonprefix(fwd_bam))
    rev_ofn = re.sub("(_2)?(_R2)?.bam$", "_R2.bam", os.path.commonprefix(rev_bam))
    cmd_fwd.extend(["-out", fwd_ofn])
    cmd_rev.extend(["-out", rev_ofn])

    # run merge commands
    dx_utils.run_cmd(cmd_fwd)
    dx_utils.run_cmd(cmd_rev)

    # combine the forward and reverse bams
    ofn = re.sub('_R1.bam$', '.combined.bam', fwd_ofn)

    cmd = 'perl two_read_bam_combiner.pl {0} {1} | /opt/biobambam2/bin/bamsormadup inputformat=sam indexfilename={2}.bai > {2} '
    cmd = cmd.format(fwd_bam, rev_bam, ofn)
    dx_utils.run_cmd(cmd)

    return {'output_bam': dxpy.dxlink(dxpy.upload_local_file(ofn, name=fwd_bam)),
            'output_bai': dxpy.dxlink(dxpy.upload_local_file(ofn + '.bai', name=fwd_bam + '.bai'))}


@dxpy.entry_point('main')
def main(fwd_reads, rev_reads, ref_genome):
    if len(fwd_reads) != len(rev_reads):
        raise dxpy.AppError("Number of forward and reverse read inputs must match")

    fwd_bams = []
    rev_bams = []
    for fwd, rev in zip(fwd_reads, rev_reads):
        fwd_bams.append(dxpy.new_dxjob({'reads': fwd, 'ref_genome': ref_genome}, 'run_bwa', name='Map forward reads').get_output_ref('output_bam'))
        rev_bams.append(dxpy.new_dxjob({'reads': rev, 'ref_genome': ref_genome}, 'run_bwa', name='Map reverse reads').get_output_ref('output_bam'))

    merge_job = dxpy.new_dxjob({'fwd_bam': fwd_bams, 'rev_bam': rev_bams}, 'combine_bams', name='Combine bams')

    output = {'output_bam': merge_job.get_output_ref('output_bam'),
              'output_bai': merge_job.get_output_ref('output_bai')}

    return output

dxpy.run()
